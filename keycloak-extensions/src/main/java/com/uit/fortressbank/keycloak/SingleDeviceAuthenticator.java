package com.uit.fortressbank.keycloak;

import org.jboss.logging.Logger;
import org.keycloak.authentication.AuthenticationFlowContext;
import org.keycloak.authentication.AuthenticationFlowError;
import org.keycloak.authentication.Authenticator;
import org.keycloak.models.KeycloakSession;
import org.keycloak.models.RealmModel;
import org.keycloak.models.UserModel;
import org.keycloak.models.UserSessionModel;

import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;

import java.security.MessageDigest;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.stream.Collectors;

public class SingleDeviceAuthenticator implements Authenticator {

    private static final Logger LOG = Logger.getLogger(SingleDeviceAuthenticator.class);

    public static final String CONFIG_FORCE_LOGIN = "forceLogin";
    public static final String CONFIG_REQUIRE_DEVICE_ID = "requireDeviceId";
    public static final String DEVICE_ID_NOTE_KEY = "deviceId";
    public static final String DEVICE_ID_PARAM = "deviceId";
    public static final String DEVICE_ID_HEADER = "X-Device-Id";

    @Override
    public void authenticate(AuthenticationFlowContext context) {
        var httpRequest = context.getHttpRequest();

        String deviceId = extractDeviceId(httpRequest.getDecodedFormParameters(),
                httpRequest.getHttpHeaders().getRequestHeaders().getFirst(DEVICE_ID_HEADER));

        boolean requireDeviceId = getBooleanConfig(context, CONFIG_REQUIRE_DEVICE_ID, true);
        boolean isDeviceIdProvided = deviceId != null && !deviceId.isBlank() && !deviceId.equals("unknown");
        boolean isAutoGenerated = false;

        if (!isDeviceIdProvided) {
            if (requireDeviceId) {
                LOG.warn("Missing deviceId on login request");
                Response challenge = Response.status(Response.Status.BAD_REQUEST)
                        .entity("{\"error\":\"deviceId_required\",\"error_description\":\"deviceId is required for login\"}")
                        .type(MediaType.APPLICATION_JSON)
                        .build();
                context.failureChallenge(AuthenticationFlowError.INVALID_CLIENT_SESSION, challenge);
                return;
            } else {
                // Generate a unique deviceId based on browser fingerprint for browser-based logins
                deviceId = generateBrowserDeviceId(context);
                isAutoGenerated = true;
            }
        }

        // Persist deviceId into the authentication session notes so that once a user session
        // is established, it will be available as a user session note for protocol mappers.
        if (context.getAuthenticationSession() != null) {
            context.getAuthenticationSession().setUserSessionNote(DEVICE_ID_NOTE_KEY, deviceId);
        }

        RealmModel realm = context.getRealm();
        KeycloakSession session = context.getSession();
        UserModel user = context.getUser();

        if (user == null) {
            LOG.debug("No user yet in context; skipping single-device enforcement");
            context.success();
            return;
        }

        List<UserSessionModel> existingSessions = session.sessions()
                .getUserSessionsStream(realm, user)
                .collect(Collectors.toList());

        if (existingSessions == null || existingSessions.isEmpty()) {
            // First login: allow and set note later when session is created.
            context.success();
            return;
        }

        boolean forceLogin = getBooleanConfig(context, CONFIG_FORCE_LOGIN, true);

        // For browser-based logins (auto-generated deviceId), always enforce single-device
        // For explicit deviceId (from mobile apps), allow same-device re-authentication
        boolean allowSameDevice = false;
        if (isDeviceIdProvided && !isAutoGenerated) {
            // Only check for same device if deviceId was explicitly provided (not auto-generated)
            for (UserSessionModel existing : existingSessions) {
                String existingDeviceId = existing.getNote(DEVICE_ID_NOTE_KEY);
                if (existingDeviceId != null && Objects.equals(existingDeviceId, deviceId)) {
                    // Same device with explicit deviceId: allow re-authentication
                    // This is useful for mobile apps that provide persistent deviceIds
                    allowSameDevice = true;
                    existing.setNote(DEVICE_ID_NOTE_KEY, deviceId);
                    break;
                }
            }
        }

        // If same device with explicit deviceId, allow login
        if (allowSameDevice) {
            context.success();
            return;
        }

        // Different device or browser-based login (auto-generated deviceId): enforce single-device
        if (forceLogin) {
            LOG.infof("Force login enabled; removing %d existing sessions for user %s (deviceId: %s)",
                    existingSessions.size(), user.getUsername(), deviceId);
            for (UserSessionModel existing : existingSessions) {
                session.sessions().removeUserSession(realm, existing);
            }
            // Also remove offline sessions
            session.sessions().getOfflineUserSessionsStream(realm, user)
                    .forEach(offlineSession -> session.sessions().removeOfflineUserSession(realm, offlineSession));
            context.success();
        } else {
            LOG.infof("Blocking login for user %s: already logged in on another device (deviceId: %s)",
                    user.getUsername(), deviceId);
            Response challenge = Response.status(Response.Status.CONFLICT)
                    .entity("{\"error\":\"already_logged_in\",\"error_description\":\"Already logged in on another device\"}")
                    .type(MediaType.APPLICATION_JSON)
                    .build();
            context.failureChallenge(AuthenticationFlowError.USER_CONFLICT, challenge);
        }
    }

    @Override
    public void action(AuthenticationFlowContext context) {
        // No-op; all logic handled in authenticate
        context.success();
    }

    @Override
    public boolean requiresUser() {
        return true;
    }

    @Override
    public boolean configuredFor(KeycloakSession session, RealmModel realm, UserModel user) {
        return true;
    }

    @Override
    public void setRequiredActions(KeycloakSession session, RealmModel realm, UserModel user) {
        // No required actions
    }

    @Override
    public void close() {
        // No-op
    }

    private String extractDeviceId(Map<String, List<String>> formParameters, String headerDeviceId) {
        if (formParameters != null) {
            List<String> values = formParameters.get(DEVICE_ID_PARAM);
            if (values != null && !values.isEmpty()) {
                String fromForm = values.get(0);
                if (fromForm != null && !fromForm.isBlank()) {
                    return fromForm;
                }
            }
        }
        if (headerDeviceId != null && !headerDeviceId.isBlank()) {
            return headerDeviceId;
        }
        return null;
    }

    private boolean getBooleanConfig(AuthenticationFlowContext context, String key, boolean defaultValue) {
        String value = context.getAuthenticatorConfig() != null
                ? context.getAuthenticatorConfig().getConfig().get(key)
                : null;
        if (value == null) {
            return defaultValue;
        }
        return Boolean.parseBoolean(value);
    }

    /**
     * Generates a unique deviceId for browser-based logins using browser fingerprinting.
     * This creates a consistent identifier based on User-Agent, IP address, and other headers.
     */
    private String generateBrowserDeviceId(org.keycloak.authentication.AuthenticationFlowContext context) {
        var httpRequest = context.getHttpRequest();
        try {
            StringBuilder fingerprint = new StringBuilder();
            
            // User-Agent (browser and OS info)
            String userAgent = httpRequest.getHttpHeaders().getRequestHeaders().getFirst("User-Agent");
            if (userAgent != null) {
                fingerprint.append(userAgent);
            }
            
            // IP address (from various headers)
            String ipAddress = httpRequest.getHttpHeaders().getRequestHeaders().getFirst("X-Forwarded-For");
            if (ipAddress == null || ipAddress.isEmpty()) {
                ipAddress = httpRequest.getHttpHeaders().getRequestHeaders().getFirst("X-Real-IP");
            }
            if (ipAddress != null && !ipAddress.isEmpty()) {
                // Take first IP if comma-separated list
                ipAddress = ipAddress.split(",")[0].trim();
                fingerprint.append("|").append(ipAddress);
            }
            
            // Accept-Language (browser language settings)
            String acceptLanguage = httpRequest.getHttpHeaders().getRequestHeaders().getFirst("Accept-Language");
            if (acceptLanguage != null) {
                fingerprint.append("|").append(acceptLanguage);
            }
            
            // Create a hash of the fingerprint for consistent deviceId
            MessageDigest md = MessageDigest.getInstance("SHA-256");
            byte[] hash = md.digest(fingerprint.toString().getBytes());
            
            // Convert to hex string and take first 16 characters
            StringBuilder hexString = new StringBuilder();
            for (byte b : hash) {
                String hex = Integer.toHexString(0xff & b);
                if (hex.length() == 1) {
                    hexString.append('0');
                }
                hexString.append(hex);
            }
            
            return "browser-" + hexString.substring(0, 16);
        } catch (Exception e) {
            LOG.warnf("Failed to generate browser deviceId: %s", e.getMessage());
            // Fallback: use timestamp + random to ensure uniqueness
            return "browser-" + System.currentTimeMillis() + "-" + (int)(Math.random() * 10000);
        }
    }
}


